<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dolphin NIE</title>
    <link>https://NYH-Dolphin.github.io/</link>
    <description>Recent content on Dolphin NIE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 01 Jan 2023 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://NYH-Dolphin.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Test</title>
      <link>https://NYH-Dolphin.github.io/games/test/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/test/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Unity Oculus SDK</title>
      <link>https://NYH-Dolphin.github.io/games/unity-oculus-sdk/</link>
      <pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/unity-oculus-sdk/</guid>
      <description>0. Oculus 开发相关资源  开发者社区+SDK：https://developer.oculus.com/  1. 介绍与配置  Unity Asset Store Oculus Integration：https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022
 Oculus 集成包 OculusIntegration.unitypackage 是核心 VR 功能、组件、脚本和插件的多合一源，可简化和增强 Unity 中的 Oculus 应用程序开发过程。它打包了几个重要的 SDK，为您的应用程序提供高级渲染、社交和社区建设、示例框架、音频和头像开发支持。它包括：VR、Audio Manager、Avatar、Platform、Sample framework、Spatializer 和 LipSync。
 搭建环境与配置 https://developer.oculus.com/documentation/unity/unity-conf-settings/  2. 摄像机 Camera  https://developer.oculus.com/documentation/unity/unity-add-camera-rig/
 Oculus Integration SDK 包括 OVRCameraRig Prefab，只需要把它添加到你需要的 Scene 里即可
 在 Scene 中删除预先有的 MainCamera 在 Assets/Oculus/VR/Prefab 文件夹中，拖入 OVRCameraRig 到 Scene 中  该 Prefab 包括下面几个重要的组件
OVR Camera Rig  Use Per Eye Camera：选择此选项可分别为左眼和右眼使用摄像头 Use Fixed Update For Tracking：选择此选项可以在 FixedUpdate() 方法中更新所有被跟踪的锚点，而不是 Update() 方法，以提高物理保真度。 Disable Eye Anchor Cameras：选择此选项以禁用眼睛锚点上的摄像头，在这种情况下，游戏的主摄像机被用来提供VR渲染，跟踪空间锚被更新来提供参考姿态  OVRmanager  Target Device：你可以通过调用 OVRManager.</description>
    </item>
    
    <item>
      <title>Unity Mirror</title>
      <link>https://NYH-Dolphin.github.io/games/unity-mirror/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/unity-mirror/</guid>
      <description>1. Mirror 介绍   Mirror 是完全免费的，它有很好的文档和说明
  Github Link: https://github.com/vis2k/Mirror
  文档：https://mirror-networking.gitbook.io/docs/
  教程
 https://www.bilibili.com/video/BV1q3411e7QV?spm_id_from=333.337.search-card.all.click https://www.youtube.com/watch?v=77vYKsXC4IE&amp;amp;list=PLXEG2omgKgCapAmGe20XBgd87rmxFdKhK&amp;amp;index=3    SDK：https://mirror-networking.com/docs/api/Mirror.html
  先修
 C# Unity 基础操作 网络相关知识    安装  通过 Assets Store 可以直接下载 Mirror  当安装好后，你会有一个 Mirror 文件夹和一个 ScriptTemplates 文件夹   在 Mirror/Examples 下面有一个 Pong 的文件夹，我们将以它为示例  2. Pong 游戏介绍 介绍   首先，打包一个文件出来，可以用来做 Server，Unity 内的用于 Client
  运行 exe 文件，可以看到游戏内有一些按钮</description>
    </item>
    
    <item>
      <title>Unity iTween 动画插件</title>
      <link>https://NYH-Dolphin.github.io/games/unity-itween-%E5%8A%A8%E7%94%BB%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/unity-itween-%E5%8A%A8%E7%94%BB%E6%8F%92%E4%BB%B6/</guid>
      <description>iTween 插件 API 全解析：https://www.bilibili.com/video/BV1T4411t7RS
 1. iTween 的下载和安装  在 Unity 的 AssetStore 中可以下载，可以直接免费入手 官网链接：iTween for Unity by Bob Berkebile (pixelplacement)  2. iTween 的使用方式 静态方法 void Start() { iTween.MoveAdd(gameObject, new Vector3(0,1,0), 3f); }  直接调用 iTween 的静态方法，传入需要的参数即可  Hashtable 方法  可以参考文档：iTween for Unity by Bob Berkebile (pixelplacement)  void Start() { Hashtable hash = new Hashtable(); hash.Add(&amp;#34;amount&amp;#34;, new Vector3(0,1,0)); hash.Add(&amp;#34;time&amp;#34;, 2f); iTween.MoveAdd(gameObject, hash); } 使用 iTween 提供的 Hash void Start() { iTween.</description>
    </item>
    
    <item>
      <title>Lecture1 About Game Testing</title>
      <link>https://NYH-Dolphin.github.io/notes/lecture1-about-game-testing/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/notes/lecture1-about-game-testing/</guid>
      <description>Lecture1 About Game Testing  http://testbook.gamedev.net/
 1. Content of the Book  Part I &amp;ldquo;About Game Testing&amp;rdquo;  Introduces the reader to game testing in terms of culture, philosophies, and the contribution testing makes to the final game release that everyone.   Part II &amp;ldquo;Making Games&amp;rdquo;  Reveals how an individual contributes to the overall game project. This includes the different kinds of roles and responsibilities that are required of testers through various stages of the development and production of game software.</description>
    </item>
    
    <item>
      <title>Lecture2 Making Games</title>
      <link>https://NYH-Dolphin.github.io/notes/lecture2-making-games/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/notes/lecture2-making-games/</guid>
      <description>Lecture2 Making Games 1. The Game Team 2. The Game Production Cycle </description>
    </item>
    
    <item>
      <title>Lecture3 Testing Fundamentals</title>
      <link>https://NYH-Dolphin.github.io/notes/lecture3-testing-fundamentals/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/notes/lecture3-testing-fundamentals/</guid>
      <description>Lecture3 Testing Fundamentals 1. Software Quality Game Quality Measurement Six Sigma  sigma level: defects per million lines of code, excluding comments  Phase Containment Phase containment is the ability to detect faults in the project phase in which they were introduced.
Phase Containment Effectiveness (PCE) is a measure of how well that is being done.
 If this practice is useful for understanding how well the team is capturing defects in the game code, it should also be applied to the work produced by the testers.</description>
    </item>
    
    <item>
      <title>Lecture4 Testing Techniques</title>
      <link>https://NYH-Dolphin.github.io/notes/lecture4-testing-techniques/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/notes/lecture4-testing-techniques/</guid>
      <description>Lecture4 Testing Techniques 1. Combinatorial Testing Pairwise combinatorial testing is a way to find defects and gain confidence in the game software while keeping the test sets small relative to the amount of functionality they cover
 that each value you use for testing needs to be combined at least once with each other value of the remaining parameters  Parameters Parameters are the individual elements of the game that you want to include in your combinatorial tests</description>
    </item>
    
    <item>
      <title>Lecture5 More Effective Testing</title>
      <link>https://NYH-Dolphin.github.io/notes/lecture5-more-effective-testing/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/notes/lecture5-more-effective-testing/</guid>
      <description>Lecture5 More Effective Testing 1. Defect Triggers Orthogonal Defect Classification (ODC) includes a set of Defect Triggers to categorize the way defects are caused to appear. These same triggers can be used to classify tests as well as defects. Test suites that do not account for each of the triggers will be incapable of revealing all of the defects in the game.
Operating Regions Game operation can be broken down into four stages</description>
    </item>
    
    <item>
      <title>Unity 单例</title>
      <link>https://NYH-Dolphin.github.io/games/unity-%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/unity-%E5%8D%95%E4%BE%8B/</guid>
      <description>1. Manager 很多全局控制的 GameManager 可以采取如下的单例模式以控制全局唯一
public class GameManager : MonoBehaviour { private static GameManager instance; public static GameManager Instance { get { if (instance == null) { GameObject obj = new GameObject(); obj.name = &amp;#34;PrefabManager&amp;#34;; DontDestroyOnLoad(obj); instance = obj.AddComponent&amp;lt;PrefabManager&amp;gt;(); } return instance; } } }  即，创建一个 GameObject 上面挂在指定的 Manager 的脚本代码，然后使用 DontDestoryOnLoad 控制其始终在 Scene 上  </description>
    </item>
    
    <item>
      <title>Unity 对象池</title>
      <link>https://NYH-Dolphin.github.io/games/unity-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/unity-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</guid>
      <description>1. ILSimplePool using System.Collections.Generic; namespace Util { /// &amp;lt;summary&amp;gt;  /// 简易池  /// &amp;lt;/summary&amp;gt;  public class ILSimplePool&amp;lt;T&amp;gt; { protected List&amp;lt;T&amp;gt; listActive = new List&amp;lt;T&amp;gt;(); // 活跃的对象池  protected List&amp;lt;T&amp;gt; listUnactive = new List&amp;lt;T&amp;gt;(); // 不活跃的对象池  public List&amp;lt;T&amp;gt; ActiveInfos =&amp;gt; listActive; public List&amp;lt;T&amp;gt; UnactiveInfos =&amp;gt; listUnactive; public int ActiveCount =&amp;gt; listActive.Count; public int UnactiveCount =&amp;gt; listUnactive.Count; public T this[int nIndex] =&amp;gt; listActive[nIndex]; /// &amp;lt;summary&amp;gt;  /// 从活跃池子内拿出一个对象  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public T Pop() { T pRes = default(T); if (listUnactive.</description>
    </item>
    
    <item>
      <title>E星计划-Lecture3 三维图形学基础</title>
      <link>https://NYH-Dolphin.github.io/notes/e%E6%98%9F%E8%AE%A1%E5%88%92-lecture3-%E4%B8%89%E7%BB%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/notes/e%E6%98%9F%E8%AE%A1%E5%88%92-lecture3-%E4%B8%89%E7%BB%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
      <description>1. 变换 变换简介 什么是变换  将一个坐标的点 (x, y) 映射到另一个坐标系中的点 (x&amp;rsquo;, y&amp;rsquo;)  为什么是顶点变换  行业规范  三角形网格模型作为美术制作的基础 三角形作为 GPU 绘制基础图元 顶点变换可以简化表示三角形的网格变换，属性插值表示三角形    顶点变换在游戏中的应用  成为游戏行业的基准  场景摆放 模型动作 渲染管线 美术建模    二维变换  可以任意组合 可以变换回去（可逆）  三维变换 三维变换可以用于
 几何建模 在场景中摆放物体  骨骼动画  基于投影渲染管线  其它的模型 其实，除了顶点变换，还有其它的模型
 贝塞尔曲面 体素 点云 隐式表面 SDF  变换的分类 刚体变换 Rigid Body Transform  保距变换：线段经过变换后，距离不变 保角变换：夹角经过变换后，角度不变  相似变换 Similarity Transform  保形变换 保角变换  线性变换 Linear Transform  L(p + q) = L(p) + L(q) L(ap) = a L(p)  仿射变换 Affine Transform  保平行 保线段的比例关系  投影变换 Projection Transform  保共线 可以反应不同平面直接的变换  自由变换 Free Transform  不保共线 更加复杂 eg：鱼眼相机  变换的数学表示 仿射变换     二维 三维     公式     矩阵      齐次变换 使用齐次变换矩阵，拓展一个位图，可以更加简洁的表示</description>
    </item>
    
    <item>
      <title>E星计划-Lecture2 渲染流程简述</title>
      <link>https://NYH-Dolphin.github.io/notes/e%E6%98%9F%E8%AE%A1%E5%88%92-lecture2-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/notes/e%E6%98%9F%E8%AE%A1%E5%88%92-lecture2-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</guid>
      <description>1. E 星计划大作业 基本要求  渲染引擎：BGFX 编程语言：C++/GLSL 平台：Windows/Visual Studio 2022 工程组织：CMake  Level 作业分为 5 个 level，每完成一个 level 的所有需求，则可挑战下一个 level
详见作业包里面的 README.md
 Level1（15%）  加载模型，绘制在屏幕上 添加环绕相机（Orbit Camera），并可以使用鼠标操控（类似 geometryv 的操作方式）  鼠标左键拖拽旋转镜头 鼠标滚轮缩放镜头     Level2（15%）  为模型添加基础纹理 为模型添加基础光照（Blinn-Phong） 在保留环绕相机功能的情况下，为相机添加键盘控制  WASD 控制镜头上下左右平移     Level3（25%）  把模型的直接光漫反射光照改为 PBR 模型实现  模型的金属度能正确影响漫反射光照 模型的 albedo（反照率）使用纹理控制   把模型的直接光改为 PBR 模型实现  模型的金属度、粗糙度通过纹理控制     Level4（25%）  使用 IBL（Image-Based Lighting），为模型添加环境光照的漫反射部分 使用 IBL，为模型添加环境光照的高光反射部分 添加一个包住场景的天空盒 天空盒使用 cubemap 纹理，对应 IBL 图中的 mipmap level 0   Level5（20%）  使用 ShadowMap 的方式，为模型添加阴影    提交要求  统一压缩为一个文件，格式为 zip 或 rar，大小在 200mb 以内  包含编译好的，可正常运行的二进制文件 包含录制的演示视频 包含源码文件，可以使用 CMake 生成 VS 工程，可编译运行 包含程序架构说明文档    2.</description>
    </item>
    
    <item>
      <title>E星计划-Lecture1 游戏引擎综述</title>
      <link>https://NYH-Dolphin.github.io/notes/e%E6%98%9F%E8%AE%A1%E5%88%92-lecture1-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%BB%BC%E8%BF%B0/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/notes/e%E6%98%9F%E8%AE%A1%E5%88%92-lecture1-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%BB%BC%E8%BF%B0/</guid>
      <description>1. E 星计划介绍 排期计划  Lecture1 开营仪式暨游戏引擎综述 Lecture2 渲染流程概述 Lecture3 三维图形学 &amp;amp; 基础数学 Lecture4 纹理综述 Lecture5 光照综述 Lecture6 性能优化综述 Lecture7 全局光照技术综述  完课要求 2. 游戏引擎及简史 什么是游戏引擎  一种快速开发游戏的工具，将游戏开发中繁琐的组件进行系统化、标准化的处理 可以延伸到影视作品、工业仿真等 游戏引擎 = 引擎核心组件 + 工具 游戏 = 引擎核心组件 + 内容（资源、玩法）  主流的游戏引擎  UE Unity 自研引擎  游戏的历史  1993 最早出现游戏引擎的时间，那时候游戏和引擎是一起开发的  第一个商业授权的引擎   1998 UE 1.0  到目前已经到 5.0   2005 Unity 1.0  3. 游戏引擎架构 架构概述  引擎核心组件  Core：支撑模块：内存管理、文件管理、对象系统、反射系统、多线程、主循环等 动画、渲染、物理、声音、脚本、AI、网络   工具  渲染 什么是渲染 https://www.</description>
    </item>
    
    <item>
      <title>Unity AssetBundle</title>
      <link>https://NYH-Dolphin.github.io/games/unity-assetbundle/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/unity-assetbundle/</guid>
      <description>参考链接：AssetBundle详解 - 知乎 (zhihu.com)  1. AssetBundle 介绍  AssetBundle 是将资源使用 Unity 提供的一种用于存储资源的压缩格式打包后的集合 它可以存储任何一种 Unity 可以识别的资源，如模型，纹理图，音频，场景等资源，也可以加载开发者自定义的二进制文件 文件类型是 .assetbundle/.unity3d 它们先前被设计好，很容易就下载到我们的游戏或者场景当中  AssetBundle 开发流程  创建 Asset bundle，开发者在 unity 编辑器中通过脚本将所需要的资源打包成 AssetBundle 文件 上传服务器，开发者将打包好的 AssetBundle 文件上传至服务器中，使得游戏客户端能够获取当前的资源，进行游戏的更新 下载 AssetBundle，首先将其下载到本地设备中，然后再通过 AssetBudle 的加载模块将资源加到游戏之中 加载，通过 Unity 提供的 API 可以加载资源里面包含的模型、纹理图、音频、动画、场景等来更新游戏客户端 卸载 AssetBundle，卸载之后可以节省内存资源，并且要保证资源的正常更新  2. AssetBundle 多平台打包 创建 AssetBundle  只有在 Asset 窗口中的资源才可以打包，先以 Prefab 的形式保存 单击要打包的 Prefab，在 Inspector 窗口右下角属性窗口底部会有一个 AssetBundle 的创建工具，直接创建  名称固定为小写，如果使用了大写字母之后，系统会自动转换为小写格式    打包 AssetBundle AssetBundle 创建之后需要导出，这一个过程就需要编写相应的代码实现</description>
    </item>
    
    <item>
      <title>Unity 行走与鼠标视角移动</title>
      <link>https://NYH-Dolphin.github.io/games/unity-%E8%A1%8C%E8%B5%B0%E4%B8%8E%E9%BC%A0%E6%A0%87%E8%A7%86%E8%A7%92%E7%A7%BB%E5%8A%A8/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/unity-%E8%A1%8C%E8%B5%B0%E4%B8%8E%E9%BC%A0%E6%A0%87%E8%A7%86%E8%A7%92%E7%A7%BB%E5%8A%A8/</guid>
      <description>1. 行走部分 WASD 控制行走 public float fMoveSpeed = 10f; // WASD移动速度  void Update(){ KeyBoardControl(); } private void KeyBoardControl() { if (Input.GetKey(KeyCode.W)) { transform.Translate(Vector3.forward * fMoveSpeed * Time.deltaTime); } if (Input.GetKey(KeyCode.S)) { transform.Translate(Vector3.back * fMoveSpeed * Time.deltaTime); } if (Input.GetKey(KeyCode.A)) { transform.Translate(Vector3.up * fMoveSpeed * Time.deltaTime); } if (Input.GetKey(KeyCode.D)) { transform.Translate(-1 * Vector3.up * fMoveSpeed * Time.deltaTime); } } 鼠标点击移动到指定位置 待补充
2. 鼠标移动视角部分 左右移动转动物体，上下移动转动摄像机 注意的问题是，上下移动不能转动物体，不然视角会转飞
public float fRotateSpeed = 200; // 视角移动速度 private float fLastPosX; // 上一次鼠标的位置 x private float fLastPosY; // 上一次鼠标的位置 y private float fRange = 0.</description>
    </item>
    
    <item>
      <title>Unity TMP 设置中文字体</title>
      <link>https://NYH-Dolphin.github.io/games/unity-tmp-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/games/unity-tmp-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93/</guid>
      <description>为了解决 TMP 不支持中文字体的情况，采取以下方式
1. 找到一个中文常见汉字的文档 这里给出一个链接：中文7000常用文字
2. 找到一个Font素材 在网上可以找到一些丰富的字体素材
或者本地可以下载一些字体文件，一般在 C:/Windows/Fonts 存放了一些常见字体
将想要使用的素材拖入 Unity 即可
3. 使用 TMP 创建字体 asset 打开 Window/TextMeshPro/Font Asset Creator
将字体文件拖入 Source Font File，将下载的中文常见汉字文档拖入 Character File
注意设置 Atlas Resolution，复杂的汉字需要最高的分辨率，也就是 8192 x 8192，如果选择了小的分辨率，最后可能无法显示，其它的设置可以参考截图下面的示例，也可以自行修改
配置完成后，点击 Generate Font Atlas，由于文字个数很多，可能需要相当长的一段时间才能完成生成
完成好后，旁边有一个 Save 按钮，将导出的 Font Asset 存放在指定位置即可
4. 使用 Font Asset 使用时，在创建了 TMP GameObject 的地方，把生成的 Font Asset 拖入到指定位置即可使用</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://NYH-Dolphin.github.io/posts/first_post/</link>
      <pubDate>Sat, 04 Dec 2021 20:47:37 +0800</pubDate>
      
      <guid>https://NYH-Dolphin.github.io/posts/first_post/</guid>
      <description>Hello, World! </description>
    </item>
    
  </channel>
</rss>