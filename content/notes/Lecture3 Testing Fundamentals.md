---
title: "Lecture3 Testing Fundamentals"
date: 2022-04-15
draft: false
type: "post"
tags: ["Game Testing"]
---

# Lecture3 Testing Fundamentals

## 1. Software Quality

### Game Quality Measurement

#### Six Sigma

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220409182623622.png" alt="image-20220409182623622" style="zoom:50%;" />	

- sigma level: defects per million lines of code, excluding comments

#### Phase Containment

Phase containment is the ability to detect faults in the project phase in which they were introduced. 

**Phase Containment Effectiveness (PCE)** is a measure of how well that is being done.

- If this practice is useful for understanding how well the team is capturing defects in the game code, it should also be applied to the work produced by the testers.

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220409183416440.png" alt="image-20220409183416440" style="zoom:50%;" />	

- **in-phase fault/errors**: faults that are found in the phase in which they are introduced
  - typically found by reviews, walkthroughs, or inspections
- **defects**: faults that donâ€™t get caught in the same phase in which they are introduced are said to escape
  - most noticeably found by testing and unhappy customers, but they can also be found in reviews of downstream work products

In both cases, some basic strategies to address low PCE areas are:

- Improve knowledge of the subject matter and provide relevant training.
- Have successful team members provide mentoring to less-successful members.
- Document methods used by successful individuals and deploy them throughout the team.
- Increase compliance with existing methods and standards.
- Add standards which, by design, help prevent faults.
- Add checking tools that run during the creation process, such as color-coded and syntax-aware editors.
- Add checking tools that run after the creation process, such as stronger compilers and memory leak checkers.

### Quality Plans

Each game project should establish its own plan for how quality will be monitored and tracked during the project. This is typically documented in the **Software Quality Assurance Plan (SQAP)**.

The SQAP contains **no information about testing the game**. That is covered in the gameâ€™s Software Test Plan.

An SQAP is strictly concerned with the **independent monitoring and correction of product and process quality issues**. 

#### QA Personnel

- Organizational structure of the QA team
- Describe the primary role of each person on the QA team for this project

#### Standards

- **product standards**
  - Product standards apply to the function of things that are produced as part of the game project.
  - This includes code, graphics, printed materials, and so on.
- **process standards**
  - Process standards apply to the way things are produced.
  - This includes file naming standards, code formatting standards, and maintenance of evolving project documents

#### Reviews and Audits

- A QA review is usually done by a single QA engineer who evaluates a work product or ongoing process against **some kind of reference such as a checklist or standard**.
  - Project documents, project plans, code, tests, test results, designs, and user documentation
  - Code inspection process, file backup procedures, and the use of tools to measure game performance over a network
  - Checking that all required fields in a form are filled in with the right type of data and that required signatures have been obtained

#### Feedback and Reports

- The SQAP should document what kinds of reports will be generated by SQA activities and how they will be communicated.

#### Problem Reporting and Corrective Action

- Problem reports can be very similar to the bug reports you write when testing finds a defect in the software
- Identify which organization or individual will be responsible and describe a timeframe for resolving the issue.
- Look for the causes of negative trends or patterns and suggest ways to reverse them

#### Tools, Techniques, and Methods

- Statistic
  - Pareto Chart
  - Control Charts

#### Supplier Control

- The advertisements in the store, the game packaging, the user’s manual, and the game media are all part of that experience.
- In many cases these items come from sources outside the game team, These are some of your “suppliers.”
- QA should play a role in determining that the supplied items are “fit for use.”

#### Training

- The QA training should be planned and delivered in time for QA to conduct any activities related to work products or processes using the new technology

#### Risk Management

Some typical SQA risks are

- Project deliverables go out of sync with planned audits
- QA personnel diverted to other activities such as testing
- Lack of independent QA reporting structure
- Lack of organization commitment to take corrective actions and/or close out issues raised by QA
- Insufficient funding for new QA technologies
- Insufficient funding for training in new development and/or QA technologies

## 2. Test Phases

### Production Schedule

No matter what size the game and how long the production schedule, the testing of the game should always follow the same basic structure

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411171246813.png" alt="image-20220411171246813" style="zoom: 80%;" />

- Pre-production
- Kickoff
- Alpha
- Beta
- Gold
- Release
- Post-release

### Pre-production

Project scope, design, and assets are being produced from the start that need to be evaluated, critiqued, and corrected.

Both the development and test teams can go home earlier at night if **more effort and skill is applied to testing activities at the beginning of the project** rather than trying to fix things later on by throwing more testers (and more overtime work) at it.

#### Planning Tasks

- **Determine the Scope of Testing the Project Will Require**
  - Design Document
  - TDD
  - Project Schedule

---

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411171837247.png" alt="image-20220411171837247" style="zoom:80%;" />	

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411171850212.png" alt="image-20220411171850212" style="zoom:80%;" />	

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411171901142.png" alt="image-20220411171901142" style="zoom:80%;" />	

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411171923180.png" alt="image-20220411171923180" style="zoom:80%;" />	

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411171932848.png" alt="image-20220411171932848" style="zoom:80%;" />	

----

- **Assign a Lead Tester**
- **Determine Phase Acceptance Criteria**
  - Establishing clear and unambiguous entry acceptance criteria for each phase of testing
  - Three elements are required in the certification planning for each test phase:
    - **Entry criteria**: The set of tests that a build must pass before entering a given test phase. The game won’t be considered “at Alpha” until the code passes the Alpha Entry test, for example
    - **Exit criteria**: The set of tests that a build must pass before completing a test phase.
    - **Target date**: The date both the development and test teams are working toward for a specific phase to launch.
- **Participate in Game Design Reviews**
  - stay abreast of the latest design changes
  - advice the project manager of any technical challenges or testing complication that may arise from any anticipated feature
- **Set Up the Defect Tracking Database**
  <img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411172945456.png" alt="image-20220411172945456" style="zoom:67%;" />
- **Draft Test Plan and Design Tests**
  - **Test Plan**
    - time
    - scope
    - dependencies on other groups
    - goals and milestones
    - risks
  - **Test Case**
    - an individual test that is to be performed by a tester or testers 
    - each test case has a distinct objective
  - **Test Suite**
    - a collection of related test cases that are described in further detail
    - gives step-by-step instructions about what operations to perform on the game and what details to check for as a result of each step
- **Testing Before Testing Begins**
  - **Modular Testing**
    - do very directed testing of certain narrow features in order to help them build the code


### Kickoff

The test kickoff illustrates the principle that increasing an organization’s speed results from an iterative process of identifying obstacles, designing a new process that eliminates them, and ensuring that the new way is implemented.

#### Tester Preparation

- Reads the requirements and/or documentation for the game feature being tested
- Gathers equipment, files, and programs needed for the test
- Reads through the tests

#### Kickoff Meeting

- Giving a feature overview
- Addressing feature questions
- Bringing up any special test instructions
- Bringing up and soliciting any relevant test improvement suggestions
- Addressing any test execution questions or issues
- Recording important issues on the kickoff form and providing a copy to the tester after the meeting is completed

### Alpha

Full-bore testing can begin.

Over the course of Alpha testing, **all modules of the game should be tested at least once**, and performance baselines should be established (frame rate, load times, and so on).

#### Alpha Phase Entry Criteria

- All major game features exist and can be tested
- A tester can navigate the game along some path from start to finish
- The code passes at least 50% of platform TRC
- Basic interface is complete and preliminary documentation is available to QA
- The game is compatible with most specified hardware and software  configurations
- Level scripting is implemented
- First-party controllers and memory cards work
- Final or placeholder art is in for all areas of the game
- Online multiplayer can be tested
- Placeholder audio is implemented

### Beta

The development team has, for the most part, stopped creating new code and new artwork, and will now shift their focus to perfecting what they’ve already created.

The majority of testing done by outside Beta testers during true Beta is **bug reporting and load testing**

#### Beta Phase Entry Criteria

- All features and options are implemented
- The code passes at least 100% of platform TRC
- The game can be navigated on all paths
- The entire user interface is final
- The game is compatible with all specified hardware and software configurations
- The game logic and AI is final
- All controllers work
- Final artwork is implemented
- Final audio is implemented
- All online modes are complete and testable
- All language version text is implemented and ready for simultaneous release

#### Design Lock

The focus of the test team at this point should be to continue to run the test cases against the builds in an iterative manner, because each defect fixed at this point may have introduced another defect elsewhere in the game

Toward the end of Beta, many tough decisions must be made. The teams are tired, tempers are on edge, and time is running out. In this charged atmosphere, with very little sleep themselves, the project team leaders have to make such **critical choices** as the following:

- Whether or not to implement that last-minute feature enhancement
- Whether to cut that level that just doesn’t seem to be much fun
- Which bugs to ship with

#### Letting Bugs Go

There will be times, especially later in the project, when the development team determines that they can’t (or won’t) fix a bug.

In some cases, where a post-release software update, or patch, is anticipated, a number of bugs will be designated for fixing after the game has been shipped.

Once a bug has been waived, it’s important to remind both the bug author and the test team as a whole that merely because the bug was waived doesn’t mean that it wasn’t a legitimate bug.

### Gold

It’s up to the testers to serve as the last line of protection for both the player and the project team by sniffing out any remaining hidden defects that would have a significant impact on player satisfaction

#### Release Guidelines

-  All known Severity 1 bugs (crashes, hangs, major function failures) are fixed
- Greater than 90% of all known Severity 2 bugs are fixed
- Greater than 85% of all known Severity 3 bugs are fixed
- Any known open issues have a workaround that has been communicated  to Technical Support (or documented in the README.TXT file, in the case of PC games)
- Release-level performance has been achieved (60-fps frame rate)

#### Last-Minute Defects

- There is seldom enough time in any project to find every bug.
- Every time a programmer touches the code, bugs may be introduced.
- Code changes accumulate over time, so that several iterative changes to  different parts of the game may result in a bug showing up downstream from those changes.
- Programmers are much more tired and prone to mistakes toward the end  of the project.
- Testers are much more tired and prone to miss things toward the end of the project.
- Bugs happen.

### Release

- The development team is well advised to fix only those bugs on the “must fix” list, and to avoid fixing each and every minor bug on the list in an effort to please the platform manufacturer.
- Once the game has been re-submitted and certified by the platform manufacturer, it is “Gold.” The champagne should flow. But the project is not over yet.

### Post-release

- The upside of developing and testing a patch is that it allows the development team to revisit the entire list of waived bugs and last-minute design tweaks and incorporate some additional polish into the game

## 3. Test Process

### Black Box Testing

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220409191111726.png" alt="image-20220409191111726" style="zoom: 67%;" />	

Almost all game testing is black box testing; testing done from outside the application.

No knowledge of, or access to, the source code is granted to the tester.

### White Box Testing

In contrast to black box testing, white box testing gives the tester an opportunity to exercise the source code directly in ways no end user ever could.

- Tests performed by developers **prior to submitting new code for integration** with the rest of the game
- Testing code modules that will become part of a **reusable library** across multiple games and/or platforms
- Testing code methods or functions that are **essential parts of a game engine or middleware product**
- Testing code modules within your game that **might be used by third-party developers** or “modders” who, by design, could expand or modify the behavior of your game to their own liking
- **Testing low-level routines that your game uses to support specific functions** in the newest hardware devices such as graphic cards or audio processors

### Life Cycle of a Build

A basic game testing process consists of the following steps

- Plan and design the test
- Prepare for testing
- Perform the test
- Report the results
- Repair the bug
- Return to step 1 and re-test

The testing process itself is a feedback loop between the tester and the developer

- The tester plans and executes tests on the code, then reports the bugs to the developer
- Developer fixes them and compiles a new build
- Tester plans and executes tests on

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411193138964.png" alt="image-20220411193138964" style="zoom:67%;" />	

#### Test Entry Criteria

It’s advisable to require that any code release meets some criteria for being fit to test before you do any testing on it

- The game code should be built without compiler errors. Any new compiler warnings that occur are analyzed and discussed with the test team
- The code release notes should be complete and provide the detail that testers need to plan which tests to run or re-run for this build
- Defect records for any bugs closed in the new release should be updated so they can be used by testers to make decisions about how much to test in the new build
- Tests and builds should be properly version controlled
- When you are sufficiently close to the end of the project, you also want to receive the game on the media that it will ship on. Check that the media  provided contains all of the files that would be provided to your customer

#### Version Control

Proper version control for the test team includes the following steps

- Collect all prior versions from the test team before distributing the new build. The prior  versions should be stacked together and archived until the project is complete.
- Archive all paperwork. This includes not only any build notes you received from the development team, but also any completed test suites, old test plans, screen shots, saved games, notes, .AVIs, and any other material generated during the course of testing a build. It is sometimes important to retrace steps along the paper trail, whether to assist in isolating a new defect or determining in what version an old bug was introduced.
- Verify the build number with the developer prior to duplicating it.
- In cases where builds are transmitted electronically, verify the byte count, file dates, and directory structure before building it. It’s vital in situations where builds are sent via FTP or email that the test team makes certain they are testing a version identical to the version the developers uploaded. Confirm the integrity of the transmitted build before giving it to the testers.
- Renumber all test suites and any other build-specific paperwork with the current version  number.
- Distribute the new build for smoke testing.

#### Configuration Preparation

The test lead must communicate the appropriate hardware configuration to each tester for this build

The cleanest possible testing configuration for a PC game is

- A fresh installation of the latest version of the operating system, including any patches or security updates
- The latest drivers for all components of the computer. This not only includes the obvious video card and sound card drivers, but also chipset drivers, motherboard drivers, ethernet card drivers, and so on
- The latest versions of any “helper apps” or middleware the game requires  to run. These can range from Microsoft’s DirectX multimedia libraries to multiplayer matchmaking software such as GameSpy Arcade

#### Smoke Testing

Certify that the build is worthwhile to formally test —— smoke test

- the lead or primary tester should **launch the game, enter each module from the main menu, and spend a minute or two playing each module**
- If the game launches with no **obvious performance problems** and each module implemented so far loads with no obvious problems, it is safe to certify the build, log it, and duplicate it for the test team.

#### Regression Testing

Verify that the bugs the development team claims to have fixed in this build are indeed fixed

- By flagging the defect as verify fix, **the bug can remain in the regression set for the next build (or two)**, but out of the open set that the development team is still working on. 
- Once the bug has been verified as fixed in two or three builds, the lead tester can then close the bug with more confidence. 

#### Test Around the Bug

Before you begin to write a defect report, ask yourself questions such as the following

- Is this the only location or level where the bug occurs?
- Does the bug occur while using other characters?
- Does the bug occur in other game modes (for example, multiplayer as well as single player, skirmish as well as campaign)?
- Can I eliminate any steps along the path to reproducing the bug?
- Does the bug occur across all platforms (for example, PlayStation2 and Xbox)?
- Is the bug machine-specific (for example, does it occur only on PCs with a certain hardware configuration)?

#### Report the Results

Good bug report writing gets programmers to “see the light”of the bug. But programmers are by no means the only people who will read your bug. The audience may include

- lead tester
- project manager
- marketing or business executives
- third parties
- customer service representatives
- other testers

But before you begin to write a bug report, you have to be certain that you have all your facts

- **Brief Description**
  - The brief description must be brief enough to be read easily and quickly, but long enough to describe the bug
- **Full Description**
  - Full Description field provides the gory details
  - Should be written as **a series of brief instructions** so that anyone can follow the steps and reproduce the bug
  - The fewer steps, the better, and the fewer words, the better
- **Great Expectations**
  - **Expected Result**: describes the behavior that a normal player would reasonably expect from the game if the steps in the bug were followed
  - **Actual Result**: describes the defective behavior
- **Things to Avoid**
  - humor and jargon

## 4. Testing by the Numbers

**Test metrics** can tell you about the effectiveness and efficiency of your testing activities and results.

### Testing Progress

In order to estimate the duration of the test execution for any portion of the game project, estimate total number of tests to be performed

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411200857733.png" alt="image-20220411200857733" style="zoom:50%;" />	

- how many tests can be completed per staff-day of effort
- how much of a tester’s calendar time is actually spent on testing activities
- how many tests you expect to be redone

### Testing Effectiveness

Measure your Test Effectiveness (TE) by adding up defects and dividing by the number of tests completed

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411201116678.png" alt="image-20220411201116678" style="zoom:67%;" />	

The severity of defects introduced with each release

<img src="/images/Lecture3 Testing Fundamentals.assets/image-20220411201214386.png" alt="image-20220411201214386" style="zoom:67%;" />	

### Summary

- **Test Progress Chart** (# of tests completed by team each day, # of tests required each day)
- **Test Completed/Days of Effort** (# of tests completed, # days of test effort for each tester)
- **Test Participation** (# of days of effort for each tester, # of days each tester assigned to test)
- **Test Effectiveness** (# of defects, # of tests: for each release and/or tester) 
- **Defect Severity Profile** (# of defects of each severity for each release)
- **Star Chart** (# of defects of each severity for each tester)
- **Testing Star** (# of defects of each severity for each tester, point value of each severity)
- **Best Tester** (# of tests per tester, # of total tests, # of defects per tester, # of total defects)
